// This file included from ecaloader.c

/*
typedef struct {
  int addr;
  const char* name;
} LoaderLabel;
LoaderLabel LABELS[] = {
*/


{ 0x0028, "REGISTER A" },
{ 0x0029, "REGISTER A, hi" },
{ 0x002A, "REGISTER B, lo" },
{ 0x002B, "REGISTER B, hi" },
{ 0x002C, "REGISTER C, lo" },
{ 0x002D, "REGISTER C, hi" },
{ 0x002E, "REGISTER D, lo" },
{ 0x002F, "REGISTER D, hi" },

{ 0x0208, "LITERAL: device number / command" },
{ 0x02D4, "Some other value on the stack (should be #$C0)" },
{ 0x02F0, "Some value on the stack (should be #$9D)" },
{ 0x030B, "VAR: 030B (should be #$02), low byte of jump vector" },

{ 0x0F08, "LITERAL: file FA/SA" },
{ 0x0F0F, "LITERAL: file FA/SA" },

{ 0xC001, "DATA: JMP operand, lo ($12)" },
{ 0xC002, "DATA: JMP operand, hi ($C0)" },
{ 0xC003, "CONST ChecksumStartPage: 8" },
{ 0xC004, "CONST ChecksumEndPage: $26 (38)" },
{ 0xC099, "LOOP: Copy pages until addr high byte is $A0" },
{ 0xC0AA, "NATIVE SUB: Copy C008-C107 to (REGISTER_C)." },
{ 0xC0C2, "Copy pages to C=$CA00 and following" },
{ 0xC0C7, "LOOP: Copy pages until addr high byte is $D0" },
{ 0xC0D8, "CODE: Loop complete: delay; close; open files" },
{ 0xC118, "CODE: Read (next) sector from disk with U1 (block read)" },
{ 0xC12B, "DATA: disk command UJ" },
{ 0xC12D, "CODE: Print message \"ERROR\" on the screen" },
{ 0xC198, "NATIVE SUB: Delay (time based on A, slightly on Y)" },
{ 0xC1A9, "CODE: read data from disk (using U1 string)" },
{ 0xC1BC, "NATIVE CODE: Receive disk data, GOTO $C233" },
{ 0xC233, "CODE: Resume after reading disk. Validate data with checksum." },
{ 0xC293, "NATIVE SUB: Compute checksum of 0800 to 25FF, return 0 if correct" },
{ 0xC2D3, "NATIVE SUB: Set BUFFER-POINTER to zero" },
{ 0xC2DA, "NATIVE SUB: Send U1 (read block) command to disk drive" },
{ 0xC2F2, "Pointer to filename \"I0:\"" },
{ 0xC2F5, "Pointer to filename \"#\"" },
{ 0xC2FD, "VAR (char): U1 track, tens digit" },
{ 0xC2FE, "VAR (char): U1 track, ones digit" },
{ 0xC300, "VAR (char): U1 sector, tens digit" },
{ 0xC301, "VAR (char): U1 sector, ones digit" },
{ 0xC309, "CODE: Copy protection checks (M-W, M-R)" },
{ 0xC36F, "SUB: MEMORY-WRITE to $006A" },
{ 0xC397, "SUB: MEMORY-WRITE to $1C00" },
{ 0xC3BC, "CONT SUB: Send MEMORY-WRITE length and payload" },
{ 0xC3CE, "CODE: MEMORY-READ $1C00" },
{ 0xC40D, "C40D" },
{ 0xC41E, "C41E" },
{ 0xC423, "CODE: Listen/Unlisten/CHKIN loop" },
{ 0xC450, "CODE: Clear RAM from $8FF to $C7B7 and crash at $C7B7" },
{ 0xC45B, "NATIVE SUB: Fill color RAM, cycle color value" },
{ 0xC4BE, "SUB: Dec counter, C=0800, SCRAMx4, loop until zero" },
{ 0xC4C8, "LOOP: Decrypt until counter reaches limit" },
{ 0xC4CB, "Decrypt 8 bytes at *C, advance C 8 bytes, mutate A" },
{ 0xC4D3, "NATIVE SUB: Decrement Counter $C6BF until $C6C0" },
{ 0xC4E0, "Operand of LDA instruction at $C4DF (part of countdown code)" },
{ 0xC4EB, "NATIVE SUB: Checksum? over C[0] to C[D-1]; result in $C6C0 and A" },
{ 0xC4F9, "NATIVE CODE: LDA $C6C0 (last calculated checksum)" },
{ 0xC6BF, "VAR: Checksum calculated for addr $C008, length $DE6" },
{ 0xC6C4, "VAR: MEMORY-WRITE payload" },
{ 0xC6E6, "NATIVE CODE: Set up load screen, spread bits" },
{ 0xC7B5, "NATIVE CODE: Clear RAM from ($C7B8:C7B9) to $FFFF" },
{ 0xC7B9, "DATA: High byte of operand to STA in RAM clear code" },
{ 0xC9E2, "DATA: Value $42 for $DD03 (CIA#2 Port B data direct reg)" },

{ 0xD020, "VIC: border color" },
{ 0xD021, "VIC: background color" },
{ 0xDD03, "CIA#2: Port B data direction register" },

{ 0xE000, "E000" },

{ 0xFF93, "KERNAL_SECOND" },
{ 0xFF96, "KERNAL_TKSA" },
{ 0xFFA5, "KERNAL_ACPTR" },
{ 0xFFA8, "KERNAL_CIOUT" },
{ 0xFFAB, "KERNAL_UNTLK" },
{ 0xFFAE, "KERNAL_UNLSN" },
{ 0xFFB1, "KERNAL_LISTEN" },
{ 0xFFB4, "KERNAL_TALK" },
{ 0xFFBA, "KERNAL_SETLFS" },
{ 0xFFBD, "KERNAL_SETNAM" },
{ 0xFFC0, "KERNAL_OPEN" },
{ 0xFFC3, "KERNAL_CLOSE" },
{ 0xFFC6, "KERNAL_CHKIN" },
{ 0xFFCC, "KERNAL_CLRCHN" },
{ 0xFFD2, "KERNAL_BSOUT" },
{ 0xFFD5, "KERNAL_LOAD" },
{ 0xFFE4, "KERNAL_GETIN" },

